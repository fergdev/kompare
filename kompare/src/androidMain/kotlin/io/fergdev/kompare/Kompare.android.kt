package io.fergdev.kompare

import android.app.Application
import android.os.Environment
import android.util.Log
import androidx.compose.ui.graphics.ImageBitmap
import androidx.compose.ui.graphics.asAndroidBitmap
import androidx.test.core.app.ApplicationProvider
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.nio.ByteBuffer

public object RobolectricDeviceQualifiers {
    // Generated by [GenerateQualifiersTest.kt]
    // Data from: AOSP https://android.googlesource.com/platform/tools/base/+archive/refs/heads/mirror-goog-studio-main/sdklib/src/main/resources/com/android/sdklib/devices.tar.gz

    // Type: android-automotive-playstore
    public const val Automotive1024plandscape: String =
        "w1024dp-h768dp-normal-notlong-notround-car-mdpi-keyshidden-nonav"

    // Type: android-desktop
    public const val SmallDesktop: String =
        "w1366dp-h768dp-xlarge-long-notround-any-mdpi-keyshidden-nonav"
    public const val MediumDesktop: String =
        "w1920dp-h1080dp-xlarge-long-notround-any-xhdpi-keyshidden-nonav"
    public const val LargeDesktop: String =
        "w1920dp-h1080dp-xlarge-long-notround-any-mdpi-keyshidden-nonav"

    // Type: default
    public const val ResizableExperimental: String =
        "w411dp-h891dp-normal-notlong-notround-any-420dpi-keyshidden-nonav"
    public const val SmallPhone: String =
        "w360dp-h640dp-normal-long-notround-any-xhdpi-keyshidden-nonav"
    public const val MediumPhone: String =
        "w411dp-h914dp-normal-long-notround-any-420dpi-keyshidden-nonav"
    public const val MediumTablet: String =
        "w1280dp-h800dp-xlarge-notlong-notround-any-xhdpi-keyshidden-nonav"
    public const val NexusOne: String =
        "w320dp-h533dp-normal-long-notround-any-hdpi-keyshidden-trackball"
    public const val Nexus7: String =
        "w600dp-h960dp-large-notlong-notround-any-xhdpi-keyshidden-nonav"
    public const val Nexus9: String =
        "w1024dp-h768dp-xlarge-notlong-notround-any-xhdpi-keyshidden-nonav"
    public const val PixelC: String =
        "w1280dp-h900dp-xlarge-notlong-notround-any-xhdpi-keyshidden-nonav"
    public const val PixelXL: String =
        "w411dp-h731dp-normal-notlong-notround-any-560dpi-keyshidden-nonav"
    public const val Pixel4: String =
        "w393dp-h829dp-normal-long-notround-any-440dpi-keyshidden-nonav"
    public const val Pixel4XL: String =
        "w411dp-h869dp-normal-long-notround-any-560dpi-keyshidden-nonav"
    public const val Pixel4a: String =
        "w393dp-h851dp-normal-long-notround-any-440dpi-keyshidden-nonav"
    public const val Pixel5: String =
        "w393dp-h851dp-normal-long-notround-any-440dpi-keyshidden-nonav"
    public const val Pixel6: String =
        "w411dp-h914dp-normal-long-notround-any-420dpi-keyshidden-nonav"
    public const val Pixel6Pro: String =
        "w411dp-h891dp-normal-long-notround-any-560dpi-keyshidden-nonav"
    public const val Pixel6a: String =
        "w411dp-h914dp-normal-long-notround-any-420dpi-keyshidden-nonav"
    public const val Pixel7Pro: String =
        "w411dp-h891dp-normal-long-notround-any-560dpi-keyshidden-nonav"
    public const val Pixel7: String =
        "w411dp-h914dp-normal-long-notround-any-420dpi-keyshidden-nonav"

    // Type: android-tv
    public const val Television4K: String =
        "w960dp-h540dp-xlarge-long-notround-television-xxxhdpi-keyshidden-dpad"
    public const val Television1080p: String =
        "w960dp-h540dp-xlarge-long-notround-television-xhdpi-keyshidden-dpad"
    public const val Television720p: String =
        "w962dp-h541dp-large-long-notround-television-tvdpi-keyshidden-dpad"

    // Type: android-wear
    public const val WearOSLargeRound: String =
        "w227dp-h227dp-small-long-round-watch-xhdpi-keyshidden-nonav"
    public const val WearOSSmallRound: String =
        "w192dp-h192dp-small-long-round-watch-xhdpi-keyshidden-nonav"
    public const val WearOSRectangular: String =
        "w201dp-h238dp-small-long-notround-watch-xhdpi-keyshidden-nonav"
    public const val WearOSSquare: String =
        "w180dp-h180dp-small-long-notround-watch-xhdpi-keyshidden-nonav"
}

internal actual suspend fun saveFile(
    imageData: ImageBitmap,
    fileName: String,
    directory: String? // e.g., "MyAppImages" for a subfolder in Pictures, or null
): String? = withContext(Dispatchers.IO) {
    // Option 1: Save to MediaStore (public, recommended for user-visible images)
//    saveToMediaStore(imageData, fileName, directory)
    // Option 2: Save to App-Specific Directory (private)
    saveToAppSpecificDir(imageData.readPixelsByteArray()!!, fileName, directory)
}

private fun saveToAppSpecificDir(
    imageData: ByteArray,
    fileName: String,
    subFolder: String? // e.g., "kompare_outputs"
): String? { // Returns absolute path or null
    val environmentType =
        Environment.DIRECTORY_PICTURES // Or null if you don't want it in "Pictures" subfolder
    val context: Application = ApplicationProvider.getApplicationContext()
    val baseDir: File? = context.getExternalFilesDir(environmentType)

    val targetDir = if (!subFolder.isNullOrBlank()) {
        File(baseDir, subFolder)
    } else {
        baseDir
    }

    if (targetDir == null) {
        // Log.e("FileSave", "External files directory not available.")
        return null
    }

    if (!targetDir.exists() && !targetDir.mkdirs()) {
        // Log.e("FileSave", "Failed to create directory: ${targetDir.absolutePath}")
        return null
    }

    val imageFile = File(targetDir, fileName)
    println("Image file $imageFile")
    try {
        FileOutputStream(imageFile).use { fos ->
            fos.write(imageData)
        }
        return imageFile.absolutePath
    } catch (e: IOException) {
        Log.e("FileSave", "Failed to save to app-specific dir", e)
        return null
    }
}

// private fun saveToMediaStore(
//    imageData: ImageBitmap,
//    fileName: String,
//    subFolder: String?
// ): String? {
//    val collection = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
//        MediaStore.Images.Media.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)
//    } else {
//        MediaStore.Images.Media.EXTERNAL_CONTENT_URI
//    }
//
//    val dirPath = if (!subFolder.isNullOrBlank()) {
//        Environment.DIRECTORY_PICTURES + File.separator + subFolder
//    } else {
//        Environment.DIRECTORY_PICTURES
//    }
//
//    val contentValues = ContentValues().apply {
//        put(MediaStore.Images.Media.DISPLAY_NAME, fileName)
//        // Infer mimeType from fileName or pass it as a parameter if known
//        val mimeType = when (fileName.substringAfterLast('.', "").lowercase()) {
//            "png" -> "image/png"
//            "webp" -> "image/webp"
//            else -> "image/jpeg" // Default or error
//        }
//        put(MediaStore.Images.Media.MIME_TYPE, mimeType)
//        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
//            put(MediaStore.Images.Media.IS_PENDING, 1)
//            put(MediaStore.Images.Media.RELATIVE_PATH, dirPath)
//        }
//    }
//
//    val appContext: Application = ApplicationProvider.getApplicationContext()
//
//    val resolver = appContext.contentResolver
//    var imageUri: Uri? = null
//    var outputStream: OutputStream? = null
//
//    try {
//        imageUri = resolver.insert(collection, contentValues)
//        if (imageUri == null) throw IOException("Failed to create MediaStore record for $fileName")
//
//        outputStream = resolver.openOutputStream(imageUri)
//        if (outputStream == null) throw IOException("Failed to get output stream for $fileName")
//
//        outputStream.write(imageData.readPixelsByteArray())
//
//        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
//            contentValues.clear()
//            contentValues.put(MediaStore.Images.Media.IS_PENDING, 0)
//            resolver.update(imageUri, contentValues, null, null)
//        }
//        return imageUri.toString()
//    } catch (e: Exception) {
//        e.printStackTrace()
//        imageUri?.let { resolver.delete(it, null, null) }
//        return null
//    } finally {
//        outputStream?.close()
//    }
// }

internal actual fun ImageBitmap.readPixelsByteArray(): ByteArray? {
    val androidBitmap = this.asAndroidBitmap()
    return try {
        val byteBuffer = ByteBuffer.allocate(androidBitmap.byteCount)
        androidBitmap.copyPixelsToBuffer(byteBuffer)
        byteBuffer.array()
    } catch (e: IllegalArgumentException) {
        Log.e("FileRead", "Failed to read pixels", e)
        null
    }
}
